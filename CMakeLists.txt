cmake_minimum_required(VERSION 3.25)
project(GPUBenchmark VERSION 1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Threads REQUIRED)
set(CMAKE_SOURCES src/main.cpp src/shared/shared.cpp src/backends/cuda_backend.cpp src/backends/hip_backend.cpp src/backends/vulkan_backend.cpp src/backends/opencl_backend.cpp)
if(LINUX)
  set(CMAKE_SOURCES ${CMAKE_SOURCES}
    src/backends/linux/cuda_backend.cpp
    src/backends/linux/hip_backend.cpp
    src/backends/linux/opencl_backend.cpp
    src/backends/linux/shared.cpp
  )
elseif(APPLE)
  set(CMAKE_SOURCES ${CMAKE_SOURCES}
    src/backends/macos/cuda_backend.cpp
    src/backends/macos/hip_backend.cpp
    src/backends/macos/opencl_backend.cpp
    src/backends/macos/shared.cpp
  )
elseif(WIN32)
  set(CMAKE_SOURCES ${CMAKE_SOURCES}
    src/backends/windows/cuda_backend.cpp
    src/backends/windows/hip_backend.cpp
    src/backends/windows/opencl_backend.cpp
    src/backends/windows/shared.cpp
  )
endif()

add_executable(gpumark ${CMAKE_SOURCES})

if(LINUX OR APPLE)
  target_link_libraries(gpumark PRIVATE Threads::Threads dl)
endif()

# Optimization/stack protector
target_compile_options(gpumark PRIVATE -O2 -fstack-protector-strong)

set(CMAKE_SKIP_RPATH TRUE)
# Run on changes to backend/hip_kernels.cu:
find_program(HIPCC_EXECUTABLE hipcc)
if(HIPCC_EXECUTABLE)
  set(HIP_KERNELS_SRC ${CMAKE_SOURCE_DIR}/src/backends/modules/hip_kernels.cu)
  set(HIP_KERNELS_OUT ${CMAKE_BINARY_DIR}/hip_kernels.hsaco)
  set(HIP_KERNELS_HPP ${CMAKE_SOURCE_DIR}/src/backends/modules/hip_kernels.hpp)

  # Add a custom target for building the CUDA kernels
  add_custom_command(
    OUTPUT ${HIP_KERNELS_HPP}
    COMMAND hipcc -fgpu-rdc --genco ${HIP_KERNELS_SRC} -o ${HIP_KERNELS_OUT}
    COMMAND echo "// This file was automatically generated." > ${HIP_KERNELS_HPP}
    COMMAND echo -n "static const " >> ${HIP_KERNELS_HPP}
    COMMAND xxd -i -n hip_kernels_hsaco ${HIP_KERNELS_OUT} >> ${HIP_KERNELS_HPP}
    DEPENDS ${HIP_KERNELS_SRC}
    COMMENT "Building HIP kernels"
  )

  add_custom_target(hip_kernels ALL DEPENDS ${HIP_KERNELS_HPP})
  add_dependencies(gpumark hip_kernels)
endif()

find_program(NVCC_EXECUTABLE nvcc)
if(NVCC_EXECUTABLE)

  set(CUDA_KERNELS_SRC ${CMAKE_SOURCE_DIR}/src/backends/modules/cuda_kernels.cu)
  set(CUDA_KERNELS_OUT ${CMAKE_BINARY_DIR}/cuda_kernels.ptx)
  set(CUDA_KERNELS_HPP ${CMAKE_SOURCE_DIR}/src/backends/modules/cuda_kernels.hpp)

  add_custom_command(
    OUTPUT ${CUDA_KERNELS_HPP}
    COMMAND nvcc -ptx ${CUDA_KERNELS_SRC} -o ${CUDA_KERNELS_OUT}
    COMMAND echo "// This file was automatically generated by ${PROJECT_NAME} ${PROJECT_VERSION}." > ${CUDA_KERNELS_HPP}
    COMMAND echo "static const char* cudaKernels_ptx = R\\\"ptx\\(" >> ${CUDA_KERNELS_HPP}
    COMMAND cat ${CUDA_KERNELS_OUT} >> ${CUDA_KERNELS_HPP}
    COMMAND echo "\")ptx\\\";\"" >> ${CUDA_KERNELS_HPP}
    DEPENDS ${CUDA_KERNELS_SRC}
    COMMENT "Building CUDA kernels"
  )

  add_custom_target(cuda_kernels ALL DEPENDS ${CUDA_KERNELS_HPP})
  add_dependencies(gpumark cuda_kernels)

endif()

# OpenCL kernels are not precompiled, but we can still track changes
set(OPENCL_KERNELS_SRC ${CMAKE_SOURCE_DIR}/src/backends/modules/opencl_kernels.cl)
set(OPENCL_KERNELS_HPP ${CMAKE_SOURCE_DIR}/src/backends/modules/opencl_kernels.hpp)

add_custom_command(OUTPUT ${OPENCL_KERNELS_HPP}
  COMMAND echo "// This file was automatically generated by ${PROJECT_NAME} ${PROJECT_VERSION}." > ${OPENCL_KERNELS_HPP}
  COMMAND echo "static const char* openclKernelSource = R\\\"cl\\(" >> ${OPENCL_KERNELS_HPP}
  COMMAND cat ${OPENCL_KERNELS_SRC} >> ${OPENCL_KERNELS_HPP}
  COMMAND echo "\")cl\\\";\"" >> ${OPENCL_KERNELS_HPP}
  DEPENDS ${OPENCL_KERNELS_SRC}
  COMMENT "Building OpenCL kernels"
)

add_custom_target(opencl_kernels ALL DEPENDS ${OPENCL_KERNELS_HPP})
add_dependencies(gpumark opencl_kernels)
